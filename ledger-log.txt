## First impressions

Oh my, that's badly written. Duplicated code everywhere. Let's start by cleaning
up all those "if locale = (hardcoded string)" statements and turning them into
a function that looks up the appropriate text given a locale and a "key" string.
In a larger project we could make that into a resource lookup.

## Step 1

Wrote a "Resource" module to keep everything in one place. It will **kind of**
simulate accessing a .Net resource compiled into our DLL.

Wrote a simple `isValidLocale` predicate. Since the other Resource module
functions are going to be partial matches, this ensures that we'll get an error
right away if an invalid locale is passed in. A compile-time error with a DU
would be better, but that would require modifying the test code.

Tests still pass.

## Step 2

Let's write a table of strings, and a lookup function to look them up by a key
string. We'll test it by using it to build the header string.

## Step 3

That works, but the column widths are hardcoded in multiple places. Let's fix
that with a list of column headings and widths. We've still only fixed the
header so far, but it's starting to look better.

## Step 4

The padding logic for the description column could be pulled out into its own
function, and then that function could be reused in the header formatting as
well. That way if we ever have a language where one of the headings is longer
than its column, it too will be truncated with an ellipsis.

## Step 5

The date formatting for the first column could also be pulled out into its own
function. We can reuse our string lookup function from step 2 to look up the
date-format string (e.g., "yyyy-MM-dd").

## Step 6

Currency formatting is tricky. The "standard" way to format numbers varies
between locales, and the answer to "how do you format negative numbers?" can
change when you're dealing with currency. (For example, in America, you drop the
negative sign but wrap the value, currency symbol included, in parentheses.) We
will use quite a number of small helper functions for this one, and it's best to
group them into a module. In a real project these modules would be in separate
files, but in Exercism you submit single files as solutions, so I'll leave the
modules in the solution file.

Now that currency formatting has been moved out into separate functions, the
`formatLedger` function is starting to look quite a bit nicer. But we still need
to deal with the ugliness of building up a result string by repeated mutation,
and inefficient O(N^2) mutation (via string addition) at that. 